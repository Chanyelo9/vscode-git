# 目录
[TOC]
****
# 一、存储引擎
## 1. MySQL体系结构
![](${currentFileDir}/20230528204729.png)

## 2. 简介
存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可以被称为表类型。
查询建表语句：
```q
show create table account;
```
查询当前数据库支持的存储引擎：
```q
show engines;
```
在存储表式，指定存储引擎
![](${currentFileDir}/20230528210150.png)

## 3.存储引擎特点
* ### InnoDB
  ![](${currentFileDir}/20230528210559.png)

  ![](${currentFileDir}/20230711135333.png)

  #### 逻辑存储结构
  ![](${currentFileDir}/20230528211203.png)

* ### MyISAM
  ![![](${currentFileDir}/20230528210559.png)](${currentFileDir}/20230711112217.png)
* ### MyISAM
  ![](${currentFileDir}/20230711134746.png)

## 总结
体系结构：连接层、服务层、引擎层、存储层

## 存储引擎选择
![](${currentFileDir}/20230711140014.png)

# 二、索引
xshell上传文件到服务器：rz -y
sudo alien -r

## 1.索引概述
索引是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。
## 2.索引结构
> 数据格式化网站 
###
#### 1.B-tree（多路平衡查找树） 
以一颗最大度数为5（5阶）的b-tree为例（每个节点最多存储4个key，5个指针）：
> 树的度数指的是一个节点的子节点个数。
![](${currentFileDir}/20230904110205.png) 

#### 2.二叉树
选择二叉树作为索引结构存在的缺点：
* 顺序插入时，会形成一个链表，查询性能大大降低
* 大数据量情况下，层级较深，检索速度慢

> 若选择红黑树？
> 红黑树是一颗自平衡二叉树，即使顺序插入数据，最终形成的数据结构也是一颗平衡的二叉树。

#### 3.B+tree
以一颗最大度数为4的b+tree为例：
![](${currentFileDir}/20230904111129.png)

> 与B-Tree区别：
> * 所有数据都会出现在叶子节点上
> * 叶子节点形成一个单向链表

* #### MySQL索引数据结构对经典B+Tree的优化
  增加一个指向相邻叶子节点的链表指针，形成有顺序指针的B+Tree，提高区间访问性能。
  ![](${currentFileDir}/20230904111358.png)

InnoDB存储引擎结构：表空间、段、区、页（默认16k）、行

### 2.Hash哈希索引
哈希索引就是采用一定的hash算法，将键值换算成新的Hash值，映射到对应的槽位上，然后存储在hash表中。
如果两个（或多个）键值，映射到同一槽位上，就产生了hash冲突，可以通过链表解决。
![](${currentFileDir}/20230904112314.png)

> 特点
> * hash索引只能用于对等比较（=，in），不支持范围查询（between，>，<）
> * 无法利用索引完成排序操作
> * 查询效率高，一般一次检索就行，效率通常高于B+Tree索引
### 3.思考
![](${currentFileDir}/20230904113003.png)

## 3.索引分类
1.分类
![](${currentFileDir}/20230905213451.png)

2.聚集索引&二级索引
根据存储形式分类：
![](${currentFileDir}/20230905213546.png)

聚集索引选取规则:
如果存在主键，主键索引就是聚集索引。
如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。
如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。

聚集索引的叶子节点下挂的是这一行的数据。
二级索引的叶子节点下挂的是该字段值对应的主键值。

回表查询：
这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。
## 4.索引语法
创建索引：
![](${currentFileDir}/20230904195036.png)

单列索引与联合索引（取决于括号名字数量）
查看索引：
![](${currentFileDir}/20230904195254.png)

删除索引：
![](${currentFileDir}/20230904195323.png)

联合索引：
![](${currentFileDir}/20230905215428.png)

## 5.SQL性能分析
SQL执行频率
![](${currentFileDir}/20230904212749.png)
> 如果是以增删改为主，我们可以考虑不对其进行索引的优化。如果是以查询为主，那么就要虑对数据库的索引进行优化了。

慢查询日志
![](${currentFileDir}/20230904214732.png)

profile详情
![](${currentFileDir}/20230904214941.png)

![](${currentFileDir}/20230904215003.png)

explain执行计划
![](${currentFileDir}/20230904221955.png)

![](${currentFileDir}/20230904225726.png)

![](${currentFileDir}/20230904230125.png)

## 6.索引使用
/G:查询结果换行
1.验证索引效率：
在未建立索引之前，执行以下查看SQL耗时：
![](${currentFileDir}/20230905110914.png)

针对字段创建索引：
![](${currentFileDir}/20230905110951.png)

再次执行相同语句查看耗时：
![](${currentFileDir}/20230905111003.png)

2.最左前缀法则
![](${currentFileDir}/20230905154328.png)

3.范围查询
联合索引中，出现范围查询，范围查询右侧的列索引失效

4.索引失败情况
索引列运算：
不要在索引列上进行运算操作，索引将失效
字符串不加引号：
字符串类型字段不使用时，不加引号，索引失效
模糊查询：
在like模糊查询中，在关键字后加%，索引生效，加在前面则索引失效
or连接条件：
用or分割开的条件，如果or之前的条件有索引，而后面没有，那么涉及到的索引都不会被用到。只有两侧都有才能生效。
数据发布影响：
如果MySQL评估使用索引比全表慢，则不使用索引。
SQL提示：
use、force、ignore
> explain select * from tb_user use index(idx_user_pro) where profession = '软件工程';
覆盖索引：
尽量使用覆盖索引，减少select *。那么什么是覆盖索引呢？覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到。
4.7.前缀索引：
当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁IO，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。

单列索引与联合索引：
单列索引：
即一个索引只包含单个列。
联合索引：
即一个索引包含了多个列。（创建时要考虑顺序，最左前缀法则），无需回表查询。

## 7.索引设计原则
1）.针对于数据量较大，且查询比较频繁的表建立索引。
2）.针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。
3）.尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。
4）.如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。
5）.尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。
6）.要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。
7）.如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。

# 三、SQL优化
1.插入数据
如需大批量插入数据，使用load指令插入：
![](${currentFileDir}/20230906112258.png)

> 切换到root用rz上传文件，pwd查看路径

2.主键优化
主键顺序插入性能高于乱序插入。
乱序插入可能产生页分裂

UID：唯一设备标识。
UUID：通用唯一识别码。
SonwFlake（雪花算法）：还包含时间戳，机器序列

1）数据组织方式
InnoDB存储引擎中，表数据都是根据主键顺序组织存放，该存储方式的表称为索引组织表。
2）页分类
乱序插入产生
每页包含2-n行数据，一行数据过大容易溢出。
3）页合并
页中的删除记录达到页的50%，InnoDB会寻找最靠近的页（前后都行）看是否可以将两个页合并以优化空间使用。
4）索引设计原则
满足业务需求的情况下，尽量降低主键长度。



3.order by优化
创建联合索引，只使用index没有filesort的前提是使用覆盖索引（只查询索引的内容），且满足最左前缀法则。
A.根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。
B.尽量使用覆盖索引。
C.多字段排序,一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。
D.如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)。
![](${currentFileDir}/20230906222342.png)

4.group by优化
在分组操作中，我们需要通过以下两点进行优化，以提升性能：
A.在分组操作时，可以通过索引来提高效率。
B.分组操作时，索引的使用也是满足最左前缀法则的。

5.limit优化
在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。
优化思路:
一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。
![](${currentFileDir}/20230906220938.png)

6.count优化
![](${currentFileDir}/20230906215554.png)

按照效率排序的话，count(字段)< count(主键id) < count(1) ≈ count(*)，所以尽量使用count(*)。

7.update优化
InnoDB的行锁是针对索引加的锁，不是针对记录加的锁,并且该索引不能失效，否则会从行锁升级为表锁。

# 四、视图/存储过程/触发器

# 五、锁

# 六、InnoDB引擎

# 七、MySQL管理