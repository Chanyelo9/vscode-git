数据结构是算法需要处理问题的载体。

## 队列
* 操作受限的线性表，只允许在表的一端插入，在另一端删除。
* 将顺序队列臆造成一个环状空间即循环队列。当队首下标等于MAX_SIZE-1 后，再前进一个位置就设置为0，这可以通过取余操作完成。
* 此外，可以用链表添加操作受限也可以形成队列，但链式队列与顺序队列不同的是，链式队列原则上**没有队满**的时候。

![](${currentFileDir}/20230911195430.png)


大O表示法：
算法的时间复杂度：
* 只关注最高此项，最高次项不是1就舍去
* 时间复杂度是指最坏时间复杂度
* 只有常数项记作1,O(1)
空间复杂度：是使用的辅助空间的大小


## 2 线性表
### 2.1概念
是0个或者多个数据元素的有限序列（a0,a1,a2...an）
特性：
* 数据之间是有顺序的
* 数据元素个数是有限的
* 数据元素的类型必须相同
性质：
* a0为线性表第一个元素，只有一个后继
* an只有一个前驱
* 其他元素都有前驱后继
* 线性表能逐项访问和顺序存取
线性表的操作：
创建、销毁、清空、元素插入线性表、线性表删除元素、获取某个位置的元素、获取线性表长度

### 2.2线性表的顺序存储
是指用一段**地址连续**的存储单元依次存储线性表的数据元素

设计与实现：
#### 1.插入元素算法
* 判断线性表是否合法
* 判断插入位置是否合法
* 把最后一个元素到插入位置的元素后移一个位置
* 插入新元素
* 线性表长度加1

#### 2.优缺点：
优点：无需为线性表中的逻辑关系增加额外的空间，可以快速的获取表中合法位置。
缺点：插入和删除操作需要移动大量元素，当线性表长度变化较大时难以确定存储空间的容量。

* vector容器：
vector实现动态增加的方法：如果空间不足，那么vector会重新申请一块两倍大的空间，将原vector空间数据拷贝到新空间，释放旧空间，再把新元素插入新申请空间.

### 2.3线性表的链式存储
**不连续**的内存空间。没有容量的概念
单链表：每个节点只包含一个指针域。通过每个节点的指针域将线性表的数据元素按其逻辑次序链接起来。
* 表头结点：链表第一个节点，包含指向第一个数据元素的指针以及链表自身的一些信息。
* 数据结点：包含指向下一个数据元素的指针和数据元素的信息。
* 尾结点：其下一个元素指针为空，表示无后继。

链表的推演：
![](${currentFileDir}/20230915111051.png) 

内核链表改进版本，即企业链表：（把指针域与数据域分开）
改进之后不需要考虑偏移量计算首地址与Node的偏移量，当前地址加上偏移量才能找到下一个next。
```c++
//.h文件
typedef struct LINKNODE{
    //void* data; 删去该行相当于链表中有挂钩
    struct LINKNODE* next;
}LinkNode;
//.c文件
typedef struct MyData{
    //加挂钩node,因为node里面有next（指向下一个首地址），可以使挂钩node串起来
    //而且node是首地址，所以只需把MyData*类型转变成LinkNode* 类型
    LinkNode node;
    char name[64];
    int age;
}MyData;
```
> * MyData data1；
> 数据类型是MyData类型，节点插入链表时转换为LinkNode*类型（只是把指针域串联），不会影响第一个next，需要打印数据时再把LinkNode*类型转换到MyData类型
> * LinkNode* node = （LinkNode*）&（data1）；
> 只需要使用LinkNode*把指针域串联