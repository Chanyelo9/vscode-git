[TOC]

### lambda表达式，匿名表达式
![](${currentFileDir}/20230528185046.png)

不过值得注意的是，捕捉列表不允许变量重复传递。

mutable修饰符， 默认情况下Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。

值捕获创建了一个临时对象，拷贝了原变量的值，之后，这个临时变量与原来的变量再无任何瓜葛，lambda中操作的是这个临时变量。
而引用捕获，创建的是一个引用/指针，指向了原来的变量，lambda函数体中操作的就是变量本身。

* #### 隐式捕获
  将变量名写入捕获列表，为显式捕获。如果lambda中需要用到的非静态局部变量非常多，全部写入捕获列表，就会显得非常臃肿，有简便写法，即为隐式捕获。
  1、捕获列表的形式为"[=]"(值捕获)或者"[&]"(引用捕获);
  2、捕获列表里不能同时写"="和"&"，即"[=, &]"是非法的;
  3、隐式捕获可以和显式捕获搭配使用，但不能和同类型的显示捕获一起使用。即隐式值捕获只能搭配显式引用捕获，隐式引用捕获只能搭配显式值捕获。表现形式为："[=,&变量1,&变量2]"或者"[&,变量1,,变量2]"。

* #### 工作原理
  编译器会把一个Lambda表达式生成一个匿名类的匿名对象，并在类中重载函数调用运算符，实现了一个operator()方法。

* #### C++仿函数
  仿函数（functor）又称为函数对象（function object）是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载operator()运算符，仿函数与Lamdba表达式的作用是一致的。

* #### 使用场景
  1. 短小不需要复用函数的场景，sort排序
  ```c
  // 对于比较大小的逻辑，使用lamdba不需要在重新定义一个函数
  sort(testdata.begin(), testdata.end(), [](int a, int b){ 
    return a > b; });
  ```
  2. for_each
  3. find_if
  4. remove_if
  5. 多线程
  6. 函数指针与function
  7. 作为函数的入参
  8. Qt
