[TOC]

### lambda表达式，匿名表达式
![](${currentFileDir}/20230528185046.png)

不过值得注意的是，捕捉列表不允许变量重复传递。

修饰符， 默认情况下Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。

值捕获创建了一个临时对象，拷贝了原变量的值，之后，这个临时变量与原来的变量再无任何瓜葛，lambda中操作的是这个临时变量。
而引用捕获，创建的是一个引用/指针，指向了原来的变量，lambda函数体中操作的就是变量本身。

* #### 隐式捕获
  将变量名写入捕获列表，为显式捕获。如果lambda中需要用到的非静态局部变量非常多，全部写入捕获列表，就会显得非常臃肿，有简便写法，即为隐式捕获。
  1、捕获列表的形式为"[=]"(值捕获)或者"[&]"(引用捕获);
  2、捕获列表里不能同时写"="和"&"，即"[=, &]"是非法的;
  3、隐式捕获可以和显式捕获搭配使用，但不能和同类型的显示捕获一起使用。即隐式值捕获只能搭配显式引用捕获，隐式引用捕获只能搭配显式值捕获。表现形式为："[=,&变量1,&变量2]"或者"[&,变量1,,变量2]"。

* #### 工作原理
  编译器会把一个Lambda表达式生成一个匿名类的匿名对象，并在类中重载函数调用运算符，实现了一个operator()方法。

* #### C++仿函数
  仿函数（functor）又称为函数对象（function object）是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载operator()运算符，仿函数与Lamdba表达式的作用是一致的。

* #### 使用场景
  1. 短小不需要复用函数的场景，sort排序
  ```c
  // 对于比较大小的逻辑，使用lamdba不需要在重新定义一个函数
  sort(testdata.begin(), testdata.end(), [](int a, int b){ 
    return a > b; });
  ```
  2. for_each
  3. find_if
  4. remove_if
  5. 多线程
  6. 函数指针与function
  7. 作为函数的入参
  8. Qt

## 函数指针
形式1：返回类型(*函数名)(参数表) 
> char (*pFun)(int);
> //定义一个返回类型为char，参数为int的函数
> //从指针层面上理解该函数，即函数的函数名实际上是一个指针，
> //该指针指向函数在内存中的首地址
而typedef可以让函数指针更直观方便:
形式2：typedef  返回类型(*新类型)(参数表)
> 例：
> typedef char (*PTRFUN)(int);
> 以一个int为参数并返回char类型。后面就可以像使用int,char一样使用PTRFUN了

* typedef void*(*FUNC)(void*);参数是void*，返回类型也是void*的函数指针

## 函数指针 & 指针函数
指针函数定义：int *fun(int x); 函数指针定义：int (*f)(int); 

## define & typedef
typedef 是在**编译**过程中被解析的，而 #define 是在编译之前的**预处理时**被破解的； #define 只是对所定义的别名的简单替换，而 typedef 则要灵活的多。

## 指针数组 & 数组指针
int *p[4]; //定义一个指针数组，该数组中每个元素是一个指针，每个指针指向哪里就需要程序中后续再定义了。
int (*p)[4]; //定义一个数组指针，该指针指向含4个元素的一维数组（数组中每个元素是int型）。

区分int *p[n]; 和int (*p)[n]; **看运算符的优先级**
int *p[n]; 中，运算符[ ]优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组。
int (*p)[n]; 中( )优先级高，首先说明p是一个指针，指向一个整型的一维数组。

## 一个类成员调用另一个类成员的方法
主要有四种：类的组合、友元类、类的前向声明、单利模式。
* 类的前向:声明只能用于定义指针、引用、以及用于函数形参的指针和引用
前向声明的类是不完全的类型，因为只进行了声明而没有定义
前向声明的作用：
在预处理时，不需要包含#include"xxx",相对节约编译时间
方便的解决两种类类型互相使用的问题。
* 单例模式是程序设计模式中最常用的模式之一，其主要思想是将类的构造函数声明为私有的防止被外部函数实例化，内部保存一个private static的类指针保存唯一的实例，实例的实现由一个public的类方法代劳，该方法返回单例类唯一的实例。
> 采用单例模式的对象在进程结束才被释放。


不能确定的东西可以交给用户去处理，通过回调函数与用户交互，相当于C++的多态


## 动态数组
很多情况下，在预编译过程阶段，数组长度不能预先知道，必须在程序运行时动态给出。
C++要求定义数组时，明确给定数组的大小
```c++
正确定义：
int size = 50;
int *p = new int[size];
不通过定义：
int size = 50,column = 50;
int(*p)[Column] = new int [size][Column]
```
原因：new int [size][Column]是在动态生成时确定的，而是int(*p)[Column]出错。这是一个定义语句，而定义语句先经过编译器进行编译，当编译器运行到此时，发现Column不是常数，索引不能通过。之所以编译器认为Column 不是常数，是因为编译阶段，编译器起的作用是查语法错误，和预分配空间，它并不执行程序，因此，没有执行那个赋值语句（只是对这个语句检查错误，和分配空间），因此编译阶段，它将认为column 是个变量。所以上面的二维数组定义是错误的， 它不能通过编译。
可以改成这样：
  int size=50
  int (*p)[50]=new int [size][50]
  由此可见，这种动态分配数组，仅对一维数组空间是真正动态分配的。对二维数组的话，
  须编译之前预先知道二维数组每一列的长度。

  int **p= new int*[size];//定义指针数组 
  int *p[5];//  假若知道二维数组的行数为5
  然后对指针数组中的每一个指针分配一个一维数组空间，这样便动态定义了二维数组。


## 面试题--list和vector如何选择
[https://zhuanlan.zhihu.com/p/639218958]

list被称为双向链表，和C中手写双向链表本质上没有大的区别。有一个指向上的指针，应该指向下的指针。与c双链表不同的是，list有一个base node不存数据，从C++11开始，此node中包含一个size_t类型的成员变量，用来记录list长度。size（）的时间复杂度由O（1）变到O(N)。

添加和删除元素会导致迭代器失效吗？
答：并不会，因为在任意位置添加和删除元素只需要改变prev/next指针指向的对象，而不需要移动元素的位置，所以不会导致迭代器失效。

list和vector相比，有哪些优势？什么情况下使用list，什么情况下使用vector？
主要有2点优势：1.list在随机插入数据不会导致数据的搬移。2.list随机删除也不会导致数据搬移。所以在频繁的随机插入/删除的场景使用list，其他场景使用vector。

遍历两个元素数目相同的vector和list，哪个效率高？
vector和list的遍历效率都是O(N)，但vector底层采用数组存储数据，所以它的空间局部性更好，对缓存更友好（Cache-friendly），所以遍历vector的效率要高于遍历list。

## 虚函数表
编译器之所以能通过指针指向的对象找到虚函数，是因为在创建对象时额外增加了虚函数表。如果一个类包含了虚函数，那么在创建该类的对象时就会额外地**增加一个数组**，数组中的每一个元素都是虚函数的**入口地址**。不过**数组和对象是分开存储的**，为了将对象和数组关联起来，编译器还要在对象中安插一个**指针**，指向数组的起始位置。这个数组就是虚函数表。

## C++的对象内存模型：
* 如果没有虚函数也没有虚继承，那么对象内存模型中只有成员变量。
* 如果类包含了虚函数，那么会额外添加一个虚函数表，并在对象内存中插入一个指针，指向这个虚函数表
* 如果类包含了虚继承，那么会额外添加一个虚基类表，并在对象内存中插入一个指针，指向这个虚基类表。


几种重载：
```c++
void operator()(const int &a)
    {
        std::cout<<a<<std::endl;
    }

```


## vector迭代器失效问题总结
（1）当执行erase方法时，指向删除节点的迭代器全部失效，指向删除节点之后的全部迭代器也失效
（2）当进行push_back（）方法时，end操作返回的迭代器肯定失效。
（3）当插入(push_back)一个元素后，capacity返回值与没有插入元素之前相比有改变，则需要重新加载整个容器，此时first和end操作返回的迭代器都会失效。
（4）当插入(push_back)一个元素后，如果空间未重新分配，指向插入位置之前的元素的迭代器仍然有效，但指向插入位置之后元素的迭代器全部失效。

## deque迭代器失效总结：
（1）对于deque,插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用都会失效，但是如果在首尾位置添加元素，迭代器会失效，但是指针和引用不会失效
（2）如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器全部失效
（3）在其首部或尾部删除元素则只会使指向被删除元素的迭代器失效。


## 关联类容器（map、set、multimap、multiset）
删除当前的iterator，只会使当前的iterator失效，只要在erase之前，递增当前iterator就行。这是因为map这类容器使用红黑树来实现，插入、删除一个结点不会对其他结点造成影响。erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。
map是关联容器，以红黑树或者平衡二叉树组织数据，虽然删除了一个元素，整棵树也会调整，以符合红黑树或者二叉树的规范，但是单个节点在内存中的地址没有变化，变化的是各节点之间的指向关系。

## new malloc
```c++
//创建类的实例
T* t = new T;
T* t = (T*)malloc(sizeof(T));
```

## 私有析构函数
控制类对象的销毁，会将析构函数设为私有
防止栈上对象的创建，如类的实例化 Test t;

## 资源竞争的线程安全问题
互斥锁和原子变量

## 内存池
定长、不定长
1.按实际分配，最先分配，最合适的分配，但很多的碎片，slab，slob
2.分配合适的大小，按照合适的分配


## 指针
指针其实是一个内存**地址**，对于一个内存单元来说，单元的地址即为指针。

而我们平时常用的指针则是**指针变量**。
指针变量从字面意思上可以看出是存储指针的一种变量类型。
在C语言中，允许用一个变量来存放指针，这种变量称为指针变量。

也就是，指针是一个地址，是一个常量。而指针变量却可以赋予不同的指针(指针也就是地址)，是变量。但我们常把指针变量简称为指针。

现在大家明白了吧，指针其实就是地址的别称，而指针变量就是存放这个地址的，所以我们平时说的定义一个指针，就是定义一个指针变量，我们可以给这个指针赋上变量的地址、数组首地址、结构体首地址等等。

！！！另外注意一下指针变量的赋值只能赋予地址。
另外这里介绍两个指针有关的运算符，在下面会用到
(1) &：取地址运算符，一般形式为： &变量名
(2) *：指针运算符(也就是获取该指针所指向的数据)，一般形式为： *指针变量


## 函数对象 函数指针
C++函数对象实质上是一个实现了operator()--括号操作符--的类。例如：
```c++
class Add  
{  
public:  
int operator()(int a, int b)  
{  
return a + b;  
}  
};  
Add add; // 定义函数对象  
cout << add(3,2); // 5
```
函数指针版本就是：
```c++
int AddFunc(int a, int b)  
{  
return a + b;  
}  
typedef int (*Add) (int a, int b);  
Add add = &AddFunc;  
cout << add(3,2); 
```
> 除了定义方式不一样，使用方式可是一样的。


## c_str
功能：c_str() 函数可以将 const string* 类型 转化为 const char* 类型
头文件：#include<cstring>

c_str()就是将C++的string转化为C的字符串数组，c_str()生成一个const char *指针，指向字符串的首地址
因为在c语言中没有string类型，必须通过string类对象的成员函数 c_str() 把 string 转换成c中的字符串样式

注意点：
c_str() 这个函数转换后返回的是一个临时指针，不能对其进行操作
所以因为这个数据是临时的，所以当有一个改变这些数据的成员函数被调用后，该数据就会改变失效；
因此要么直接将这个数据应用或输出，要么把它的数据用 strcpy() 函数复制到自己可以管理的内存中；
