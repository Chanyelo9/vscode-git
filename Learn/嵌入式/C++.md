[TOC]

### lambda表达式，匿名表达式
![](${currentFileDir}/20230528185046.png)

不过值得注意的是，捕捉列表不允许变量重复传递。

mutable修饰符， 默认情况下Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。

值捕获创建了一个临时对象，拷贝了原变量的值，之后，这个临时变量与原来的变量再无任何瓜葛，lambda中操作的是这个临时变量。
而引用捕获，创建的是一个引用/指针，指向了原来的变量，lambda函数体中操作的就是变量本身。

* #### 隐式捕获
  将变量名写入捕获列表，为显式捕获。如果lambda中需要用到的非静态局部变量非常多，全部写入捕获列表，就会显得非常臃肿，有简便写法，即为隐式捕获。
  1、捕获列表的形式为"[=]"(值捕获)或者"[&]"(引用捕获);
  2、捕获列表里不能同时写"="和"&"，即"[=, &]"是非法的;
  3、隐式捕获可以和显式捕获搭配使用，但不能和同类型的显示捕获一起使用。即隐式值捕获只能搭配显式引用捕获，隐式引用捕获只能搭配显式值捕获。表现形式为："[=,&变量1,&变量2]"或者"[&,变量1,,变量2]"。

* #### 工作原理
  编译器会把一个Lambda表达式生成一个匿名类的匿名对象，并在类中重载函数调用运算符，实现了一个operator()方法。

* #### C++仿函数
  仿函数（functor）又称为函数对象（function object）是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载operator()运算符，仿函数与Lamdba表达式的作用是一致的。

* #### 使用场景
  1. 短小不需要复用函数的场景，sort排序
  ```c
  // 对于比较大小的逻辑，使用lamdba不需要在重新定义一个函数
  sort(testdata.begin(), testdata.end(), [](int a, int b){ 
    return a > b; });
  ```
  2. for_each
  3. find_if
  4. remove_if
  5. 多线程
  6. 函数指针与function
  7. 作为函数的入参
  8. Qt

## 函数指针
形式1：返回类型(*函数名)(参数表) 
> char (*pFun)(int);
> //定义一个返回类型为char，参数为int的函数
> //从指针层面上理解该函数，即函数的函数名实际上是一个指针，
> //该指针指向函数在内存中的首地址
而typedef可以让函数指针更直观方便:
形式2：typedef  返回类型(*新类型)(参数表)
> 例：
> typedef char (*PTRFUN)(int);
> 以一个int为参数并返回char类型。后面就可以像使用int,char一样使用PTRFUN了

* typedef void*(*FUNC)(void*);参数是void*，返回类型也是void*的函数指针

## 函数指针 & 指针函数
指针函数定义：int *fun(int x); 函数指针定义：int (*f)(int); 

## define & typedef
typedef 是在**编译**过程中被解析的，而 #define 是在编译之前的**预处理时**被破解的； #define 只是对所定义的别名的简单替换，而 typedef 则要灵活的多。

## 指针数组 & 数组指针
int *p[4]; //定义一个指针数组，该数组中每个元素是一个指针，每个指针指向哪里就需要程序中后续再定义了。
int (*p)[4]; //定义一个数组指针，该指针指向含4个元素的一维数组（数组中每个元素是int型）。

区分int *p[n]; 和int (*p)[n]; **看运算符的优先级**
int *p[n]; 中，运算符[ ]优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组。
int (*p)[n]; 中( )优先级高，首先说明p是一个指针，指向一个整型的一维数组。

## 一个类成员调用另一个类成员的方法
主要有四种：类的组合、友元类、类的前向声明、单利模式。
* 类的前向:声明只能用于定义指针、引用、以及用于函数形参的指针和引用
前向声明的类是不完全的类型，因为只进行了声明而没有定义
前向声明的作用：
在预处理时，不需要包含#include"xxx",相对节约编译时间
方便的解决两种类类型互相使用的问题。
* 单例模式是程序设计模式中最常用的模式之一，其主要思想是将类的构造函数声明为私有的防止被外部函数实例化，内部保存一个private static的类指针保存唯一的实例，实例的实现由一个public的类方法代劳，该方法返回单例类唯一的实例。
> 采用单例模式的对象在进程结束才被释放。


不能确定的东西可以交给用户去处理，通过回调函数与用户交互，相当于C++的多态


## 动态数组
很多情况下，在预编译过程阶段，数组长度不能预先知道，必须在程序运行时动态给出。
C++要求定义数组时，明确给定数组的大小
```c++
正确定义：
int size = 50;
int *p = new int[size];
不通过定义：
int size = 50,column = 50;
int(*p)[Column] = new int [size][Column]
```
原因：new int [size][Column]是在动态生成时确定的，而是int(*p)[Column]出错。这是一个定义语句，而定义语句先经过编译器进行编译，当编译器运行到此时，发现Column不是常数，索引不能通过。之所以编译器认为Column 不是常数，是因为编译阶段，编译器起的作用是查语法错误，和预分配空间，它并不执行程序，因此，没有执行那个赋值语句（只是对这个语句检查错误，和分配空间），因此编译阶段，它将认为column 是个变量。所以上面的二维数组定义是错误的， 它不能通过编译。
可以改成这样：
  int size=50
  int (*p)[50]=new int [size][50]
  由此可见，这种动态分配数组，仅对一维数组空间是真正动态分配的。