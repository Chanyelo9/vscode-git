出现open:bad address的原因:
在调用open时，没有检查argc的值是否足够大来确保argv[1]存在。如果没有足够的命令行参数传递给程序，argv[1] 可能为空，或者没有有效的文件路径作为参数，这会导致open函数失败。
为了避免这个错误，你应该在访问argv[1]之前添加检查，确保至少有两个命令行参数传递给程序，即程序名称和要打开的文件路径。
```c
if (argc != 2) {
        fprintf(stderr, "Usage: %s <filename>\n", argv[0]);
        return -1;
    }
```

STL：标准模板库
聊锁提lock_gaurd

1.字符串循环右移，n=2，abcdefgh->ghabcdef  
四种方法：遍历交换，库函数strcpy，strncpy，strcat，内存操作memcpy 内存复制，字符串逆置
2.不使用任何库函数实现memcpy
void *memcpy( void *dest, const void *src, size_t count );
问题：指针类型为void*，不能++；不知道拷贝内容的个数 。
引入assert如果断言为假，中止程序。
(2)char * strcpy(char * strDest,const char * strSrc);
返回值是char*为了使用链式表达式，调用strcpy使得steDest指针赋值strSrc内存数据，然后调用getStrLen获取strDest长度。
3.不使用stdio.h库实现十进制转二进制和十六进制
```c
#include <stdio.h>
#include <stdlib.h>

char* decimalToBinary(int decimal) {
    char* binary = (char*)malloc(sizeof(char) * 33); // 最大32位二进制数
    int index = 0;

    while (decimal > 0) {
        binary[index++] = (decimal % 2) + '0';
        decimal /= 2;
    }

    binary[index] = '\0';
    return binary;
}

char* decimalToHexadecimal(int decimal) {
    char* hexadecimal = (char*)malloc(sizeof(char) * 9); // 最大8位十六进制数
    int index = 0;

    while (decimal > 0) {
        int remainder = decimal % 16;
        if (remainder < 10) {
            hexadecimal[index++] = remainder + '0';
        } else {
            hexadecimal[index++] = remainder - 10 + 'A';
        }
        decimal /= 16;
    }

    hexadecimal[index] = '\0';
    return hexadecimal;
}

int main() {
    int d;
    scanf("%d", &d);
    char* binary = decimalToBinary(d);
    char* hexadecimal = decimalToHexadecimal(d);

    printf("%d", d);
    printf("%s", binary);
    printf("%s", hexadecimal);

    free(binary);
    free(hexadecimal);
    return 0;
}
```