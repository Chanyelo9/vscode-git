[TOC]

# 课程来源于胖达说测试
# 一、计算机基础知识
![](${currentFileDir}/20230619161434.png)

# 二、html和css基础
## 1.表单
 表单标签
 ![](${currentFileDir}/20230619182122.png)

 表单属性设置：
 ![](${currentFileDir}/20230619184044.png)

表单元素属性设置：
![](${currentFileDir}/20230619184119.png)

## 2.css三种引入方式:
### 1.行内式
直接在标签的style属性中添加css样式
```html
<div style="width: 100px;height: 50px; background-color: plum;">hello</div>
```
### 2.内嵌式
在<.head.>标签内加入<style.>标签，在<style.>并且中编写css代码
```html
<head>
    <style>
        p{
            color: aquamarine; 
        }
    </style>
</head>
```
### 3.外链式
将css代码单独写在css文件中，在<.head.>标签中使用<.link.>标签直接引入该文件到页面中。
```html
<link rel="stylesheet" type="text/css" href="main.css">
```

## 3.css选择器
选择标签给标签加样式。
css选择器种类：
1.标签选择器(以标签开头)
2.类选择器(以.开头，一个类选择器可用于多个标签，一个标签也可以使用多个类选择器，多个类选择器用空格分隔)
```html
<style type="text/css">
    .blueviolet{color: blueviolet;}
    .big{font-size: 20px;}
    .box{width: 100px;height: 30px;background: antiquewhite;}
</style>

<div class="blueviolet">这是一个div</div>
<h4 class="blueviolet big">这是一个标题</h4>
<p class="blueviolet box">这是一个段落</p>
```
3.层级选择器(根据层级关系选择后代标签，以选择器1 选择器2开头，主要用在标签嵌套的结构中，减少命名)
```html
<style type="text/css">
    p{
        color: aquamarine; 
    }
    div{
        color: cadetblue;
    }
    div p{
        color: chartreuse;
    }
    .con{width: 300px;height: 100px;background: green}
    .con span{color: aqua}
    .con .pink{color: pink}
    .con .palevioletred{color: palevioletred}
</style>
<div class="con">
    <span>hahahahaha</span>
    <a href="#" class="pink">百度</a>
    <a href="#" class="palevioletred">新浪</a>
</div>
```
4.id选择器(以#开头，元素的id名称不能重复，id选择器只能对应于页面上一个元素)
id名一般给程序使用，不推荐使用id作为选择器。
```html
<style type="text/css">
    #box{color: yellow;}
</style>

<p id="box">这是一个段落标签</p>
<p>这是第二个段落标签</p>
<p>这是第三个段落标签</p>
```
5.组选择器
```html
<style type="text/css">
    .box1,.box2,.box3{width: 50px;height: 50px;}
    .box1{background-color: darkmagenta;}
    .box2{background-color: darkorchid;}
    .box3{background-color: darkviolet;}
</style>

<div class="box1">这是一个div</div>
<div class="box2">这是一个div</div>
<div class="box3">这是一个div</div>
```
6.伪类选择器(以：分割，当用户和网站交互的时候改变显示效果)
```html

```

## 4.css属性
### 1.常用属性
1.布局常用样式属性：
![](${currentFileDir}/20230620110411.png)
2.文本常用样式属性：
![](${currentFileDir}/20230620110457.png)

### 2.css元素溢出
当子元素（标签）的尺寸超过父元素的尺寸时，需要设置父元素显示溢出的子元素的方式，通过overflow属性完成。
overflow设置项：
![](${currentFileDir}/20230620111449.png)

### 3.css显示特性
1.display属性
是用来设置元素类型及隐藏的，常用的属性有：
![](${currentFileDir}/20230620112034.png)

### 4.盒子模型
把HTML页面看做一个矩形盒子，有内容、内边距、边框、外边距四块组成。
![](${currentFileDir}/20230620112537.png)

## 5.补充
```html
<a herf="www.baidu.com"> 你好</a>
#a是标签,若没有文本“你好”，只有属性，可以简写成如下：
<a herf="www.baidu.com"/>
```

# 三、测试与开发模型
## 1.测试工作流程
需求分析
测试计划和测试方案
测试用例设计
测试用例执行
评估阶段 测试报告
## 2.开发模型
### 1.瀑布模型
![](${currentFileDir}/20230620144022.png)

特点：
1.阶段间具有顺序性和依赖性
2.推迟实现
3.质量保证的观点
总结：瀑布模型是文档驱动的模型，遵守这个约束可使软件维护变得比较容易一些，从而降低软件预算。
![](${currentFileDir}/20230620144216.png)

### 2.快速原型
![](${currentFileDir}/20230620144319.png)

特点：是快速建立起来可以在计算机上运行的程序。
![](${currentFileDir}/20230620144459.png)

### 3.增量模型
![](${currentFileDir}/20230620150043.png)

特点：把瀑布模型的顺序特征和快速原型的迭代特征相结合，将软件看作一系列相互联系的增量，在开发过程的各次迭代中，每次完成其中的一个增量。
### 4.其他模型
螺旋模型、迭代模型、敏捷模型

## 3.测试模型
### 1.v模型
![](${currentFileDir}/20230620145316.png)

![](${currentFileDir}/20230620145346.png)

### 2.w模型
![](${currentFileDir}/20230620150011.png)

介绍：
![](${currentFileDir}/20230620145731.png)

特点：
![](${currentFileDir}/20230620145753.png)

## 4.软件测试分类
### 1.测试（开发）阶段
### 2.是否覆盖码源
黑盒测试:不关注源代码，针对程序UI功能进行测试。功能测试（UI测试、业务测试、文档测试、易用性测试、安装卸载测试、兼容性测试）和性能测试（一般测试（CPU使用率、GPU、内存）、稳定性测试、负载测试、压力测试）
灰盒测试:针对程序部分代码进行测试（接口）（输入输出、程序运行状态）
白盒测试:针对程序源代码进行测试（语句覆盖、判断覆盖、条件覆盖、路径覆盖）
### 3.是否运行
静态测试（测试程序结构、程序过程、接口是否正常、代码风格是否符合标准）、动态测试
### 4.是否自动化
### 5.地域测试
### 6.其他测试分类
回归测试、冒烟测试、随机测试（monkey测试）、探索测试

测试用例：
特性：有效性、可复用性、易组织性、可评估性、可管理性


# 移动测试
1.ADB 
定义：
安卓调试桥，即包含ADB服务，也包含了与服务对应的Client
作用：通过命令去操作手机。
关系：
在电脑上创建一个服务，手机连上电脑后，会与服务建立连接，要想发送指令给手机，就要吧指令发送到服务中。
命令：
1.服务：（如果发现代码连不上手机）
> adb kill-server
> adb start-server
2.查看设备：
> abd devices
3.进入手机终端
> adb shell
4.获取信息
> adb shell getprop ro.build.version.release 获取手机android版本
> adb shell dumpsys window windows | findstr mFocusedApp 获取时间当前运行的程序和界面的名称
5.文件传输
> adb push 电脑上的文件 手机上的位置
> adb pull 手机上的文件 电脑上的位置


# 基础操作

元素定位工具,网页html，xml元素快速查找：uiautomatorviewer.bat
D:\WebDownloads\android-sdk_r24.4.1-windows\android-sdk-windows\tools\bin

## driver
install_app('apk在电脑的绝对路径') 安装应用
remove_app('应用包名') 卸载应用
is_app_installed() 判断释放安装应用
push_file(目标位置)返回值是base64编码的内容  
pull_file 获取界面xml码源
page_source
find_element 
current_package 获取当前操作的应用名称
current_activity 获取当前操作的界面名称

## element
text 获取元素文本内容
click() 点击元素对应位置
get_attributr(属性名称) 获取属性值
location 获取元素左上角的坐标
size 获取元素的宽高(字典)

## 输入文本
send_keys("文本内容")
```
driver.find_element_by_xpath("//*[]").send_keys("")
```
输入中文时要加入以下：
> desired_caps['unicodeKeyboard'] = True #unicode设置，允许中文输入
> desired_caps['resetKeyboard'] = True #键盘设置，允许中文输入
* 如果对于同一个元素，多次调研此方法，会先一个一个删除掉原有内容，再输入

clear() 清空文本框内容

## 模拟手势
1.滚动
```
swipe(self,start_x: int,start_y:int,end_x:int,end_y:int, duration:int = 0)
```
> 注意duration默认值的600单位是毫秒
> click方法，实际上不是点元素，而且点元素所在位置。在获取的时候有位置，但经过滑动，位置发生了变化，可能点不准。非常有可能在点击之前睡一会，等待滑动结束。

```
scroll(origin__el, destination_el,duration)
```
scroll直接传递元素作为参数即可，不需要手动获取位置。
scroll底层实现有swipe一些区别，没有中间的采样点，只有起始，结束，但最终效果一样。

2.拖拽
在安卓，拖拽=按下 等待一定时间 移动 松手
```
drag_and_drop(origin_el,destination_el)
```

3.TouchAction
作用：构建相对比较复杂，连续的触摸行为。
用法：
1.创建TouchAction对象，需要把driver作为参数传递
2.通过各种方法添加动作。
3.执行perform（）
方法：
* 按下：
press(self,el,x,y,pressure)
> 如果传递了el参数，x，y可以不传
> el为none则要传
> pressure为iOS专用
* 长按：
  long_press(self,el,x,y,duration=1000)
* 移动
  move_to(self,el,x,y)
* 等待
  wait(self,ms)
* 松手
  release()
* 轻敲（点击）
  tap(self,element,x,y,count = 1)
> click有延迟触发效果（为了校验是不是双击）
> 通过tap（el，count=2）可以模拟双击

## driver其他操作
.device_time 获取手机时间
.get_window_size()获取屏幕大小
.network_connection 获取手机网络信息
  1 飞行模式 2 WiFi 4 移动数据 6=2+4
.set_network_connection(网络模式数字) 设置手机网络信息
.keyevent(按键数字) 点击按键
.get_screenshot_as_file/save_screenshot(图片路径) 截屏
.open_notifications() 打开通知栏

# Postman
api接口测试工具
## Postman集合测试
添加collections，Binner，参数分析，运行结果
## Postman设置变量
Collection设置变量，设置全局变量，设置环境变量，Tests设置变量
## Postman断言
![](${currentFileDir}/20230709105554.png)
## Postman随机数
{{$guid}},{{$timestamp}},{{$randomInt}}

# pytest
pytest是Python的一种单元测试框架，同自带的unittest测试框架类似。
## 特点
简单灵活，容易上手，文档丰富；
支持参数化，可以细粒度地控制要测试的测试用例；
能够支持简单的单元测试和复杂的功能测试，还可以用来做selenium/appnium等自动化测试、接口自动化测试（pytest+requests）;
pytest具有很多第三方插件，并且可以自定义扩展，比较好用的如pytest-selenium（集成selenium）、pytest-html（完美html测试报告生成）、pytest-rerunfailures（失败case重复执行）、pytest-xdist（多CPU分发）等；
测试用例的skip和xfail处理；
可以很好的和CI工具结合，例如jenkins
report框架----allure 也支持了pytest
## 编码约束
测试文件：必须满足 test_*.py 或 *_test.py 格式
测试类：以Test开头，并且不能带有 __init__ 方法（pytest只运行以Test开头的class）
测试函数：以test_开头
断言使用基本的assert即可
在执行pytest命令时，会自动从当前目录及子目录中寻找符合上述约束的测试函数来执行。
## 案例
运行：
* mian
  ```python
  import pytest
  if __name__ == '__main__':
    pytest.main() 
  ```
* 脚本
  pytest

  > 说明：
  默认是不显示程序的打印信息，如需显示，需添加-s参数：
  pytest.main(['-s‘])
  pytest -s

## 自动发现规则
  * 默认规则
    对于直接执行pytest
    * 模块
      从测试目录(testpaths)或者当前目录中,递归寻找(某些目录除外)
      名称规则为test_*.py或*_test.py
    * 类
      以上模块中的Test开头的类，且没有初始化__init___方法
    * 函数及方法
      以上模块或者类中，test开头的函数或者方法
    * 其他
      也会执行unittest定义的测试用例类
  * 自定义规则
    可以通过配置文件进行指定

## 配置文件
以pytest.ini为例：
![](${currentFileDir}/20230709172953.png)

> 注意：
![](${currentFileDir}/20230709173014.png)

## pytest 的标记  mark 
* 标记跳过测试
![](${currentFileDir}/20230709180913.png)

* 标记失败
![](${currentFileDir}/20230709181011.png)

## 参数化
对于相似的过程，但数据不一样的时候，可以使用参数化
APi：
![](${currentFileDir}/20230709185927.png)

## 夹具
用于在测试之前和测试之后执行，用于固定测试环境，及清理回收测试资源
级别：
* 模块级
  ```python
  def setup_module(module):
    pass
  def setup_module(module):
    pass
  ```
* 类级
  @classmethod 可不加
  ```python
  @classmethod
  def setup_class(cls):
    pass
  def setup_class(cls):
    pass
  ```
* 方法级
  method参数可选（方法名称为setup或teardown）
  ```python
  def setup_method(self,method):
    pass
  def teardown_method(self,method):
    pass
  ```
* 函数级
  function参数可选
  ```python
  def setup_function(function):
    pass
  def teardown_function(sfunction):
    pass
  ```

### fixture装饰器
除了setup和teardown，pytest提供fixture进行更为强大的夹具
可以把夹具看为一个过程
也可以是具备返回值的
#### 定义夹具
* 无返回值
  ```python
  @pytest.fixture()
  def before():
    print("before")
   ```
* 有返回值
  ```python
  @pytest.fixture()
  def login():
    print("login")
    return "user"
   ```
* 有参数
  ```python
  @pytest.fixture()
  def gen_data(reauest):
    print("gen_data")
  ```

#### 使用夹具
* 测试代码自己指定想要使用的夹具
  * 代码1  通常使用无返回值的夹具
  ```python
  @pytest.mark.usefixtures("before")
  def test_1():
    print('test_1()')
  ```
  * 代码2
  ```python
  def test_1(login):
    print('test_1', login)
  ```
* 在夹具函数上添加参数自动使用
  ```python
  def fixture(
    scope="function",
    params=None,
    autouse=False,
    ids=None,
    name=None
  ):
  ```
  scope夹具级别有 session module function（包含method）class
  autouse是否自动使用

#### 参数化使用夹具
```python
import pytest
@pytest.fixture(params=[1,2,3])
def init_data(request):
    print("request参数是",request.param)
    return request.param

def test_Data(init_data):
    print('test_Data :%s' %init_data)
    assert init_data>2
```
> 说明
>![](${currentFileDir}/20230709205025.png)

## pytest插件
### html报告
* 命令行：
pytest --html=存储路径/report.html
* 配置文件方式:
addopts = -s --html=./report.html

### 指定执行顺序
@pytest.mark.run(order=x)

### 失败重试
* 命令行：
pytest --reruns 5
* 配置文件方式:
addopts = -s --reruns 5